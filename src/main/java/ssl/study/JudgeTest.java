package test;

/**
 * 已知x >= y and y >= z 为真，那么x > z or y = z 值为
 *
 *
 *  构造方法是一种特殊的方法，具有以下特点。
 * （1）构造方法的方法名必须与类名相同。
 * （2）构造方法没有返回类型，也不能定义为void，在方法名前面不声明方法类型。
 * （3）构造方法的主要作用是完成对象的初始化工作，它能够把定义对象时的参数传给对象的域。
 * （4）一个类可以定义多个构造方法，如果在定义类时没有定义构造方法，则编译系统会自动插入一个无参数的默认构造器，这个构造器不执行任何代码。
 * （5）构造方法可以重载，以参数的个数，类型，顺序。
 *
 *
 共享的资源有：
 a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
 b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
 c. 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
 d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
 独享的资源有
 a. 栈 栈是独享的
 b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC

 private修饰的东西，只是不能在别的类中访问，但是本类中还是可以的。同时利用反射也可以做到。

 参数类型不同构成重载；
 返回相同，参数类型相同，参数顺序不同，例如：
 int fun( int x, int y )
 int fun( int y, int x )
 这样不是重载，因为编译器无法区别它们，从而报错。
 但
 int fun( int x, char y )
 int fun( char y, int x )
 是重载的
只需要看参数列表中的参数类型的顺序即可，不用看参数名。
 int,char  -> char,int 就是重载



 都写的啥几把玩意，我来正解，上面没看到完全正确的，所以实在忍不了写出正确的解答
 这题考察的就两个知识点：一、强制转换（主要涉及各个类型占几个字节，这里我只简单说一下byte型占一个字节，也就是8位，int型4个字节，32位）；二、在计算机系统中，数值一律用补码来表示（存储）
 正数：补码=反码=原码（当然以二进制形式表达）
 129 int类型（4个字节）二进制： 00000000 00000000 00000000 10000001
 强制转换byte型后，只有一个字节即 10000001（注意这里从二进制角度看，第一位是符号位，即求负数的补码接下来）
 只要求出上面原码对应的补码就行了，然后再转换对应的int型数值（因为题干所给的答案都是比较int型）
 10000001（原码） 对应的反码为1111 1110
 又补码等于反码+1
 即1111 1111  该二进制转换int型刚好是-127（1+2+4+8+16+32+64）

 普及一下：正数原码，反码，补码相同
 负数反码除了符号位不变，其他位取反，补码=反码+1；

 之前那些解答都啥玩意，不会别误导大家，我的是正解，嘻嘻

 */
public class JudgeTest {
    //boolean可以和Integer比较，不可以和int比较????
    public static void main(String[] args) {
        int i = 1;
        Integer I = 1;
        boolean b = true;
        Boolean B = true;
//        System.out.println(b == i);
//        System.out.println(b == I);
//        System.out.println(B == I);
//        System.out.println(B == i);
        //Operator '==' cannot be applied to 'int', 'boolean'
//        System.out.println(a == c);
    }
}
